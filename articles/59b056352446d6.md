---
title: "Steve Awodey. Category Theory ã‚’ PureScript ã§æ›¸ã„ã¦ã„ã[ç¬¬1å›(ï¼Ÿ)ãƒ»2ç« ]"
emoji: "ğŸ¤”"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["PureScript"]
published: true
---

# ã¯ã˜ã‚ã«

ã“ã®è¨˜äº‹ã¯ Steve Awodey ã® Category Theory ã‚’èª­ã¿ã¤ã¤å‡ºã¦ããŸæ¦‚å¿µã‚’ PureScript ã§å®Ÿè£…ã—ã¦ã„ãã‚‚ã®ã§ã™ï¼
"ç¬¬ 1 å›(ï¼Ÿ)"ã¨ã„ã†ã®ã¯ï¼Œæœ¬ã®é€”ä¸­ã‹ã‚‰æ›¸ã“ã†ã¨æ€ã„ç«‹ã£ãŸã®ã§æœ€åˆã‹ã‚‰ã§ã¯ãªã„ã‹ã‚‰ã§ã™ï¼(ã»ã¼æœ€åˆã§ã™ãŒ)
ã‚ã¨ç¾åœ¨èª­ã‚“ã§ã‚‹æœ€ä¸­ãªã®ã§çŸ¥è­˜ã¯ã‚ã‚Šã¾ã›ã‚“ï¼"ã‚ã‹ã‚‰ãªã„ã“ã¨ã¯ã‚ã‹ã‚‰ãªã„ã¨æ›¸ã"ç²¾ç¥ã§ã‚„ã‚Šã¾ã™ãŒï¼Œé–“é•ã£ãŸã“ã¨ã‚’æ›¸ã„ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼

# 2.3

çµ‚å¯¾è±¡$1$ã‹ã‚‰å¯¾è±¡$A$ã¸ã®å°„$1\rightarrow A$ã¯ points ã¨å‘¼ã°ã‚Œã‚‹ï¼(ç–‘å•ç‚¹: ã»ã‹ã®æ–‡çŒ®ã§ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³ãŒå¿…ãšã—ã‚‚$1$ã¨ã¯ã•ã‚Œã¦ã„ãªã„ï¼ç”¨èªã®é•ã„ï¼Ÿ)
é›†åˆã‚„åŠé †åºé›†åˆã‚’å¯¾è±¡ã¨ã—ãŸåœã®å ´åˆï¼Œå°„$f:A\rightarrow B$ã¨$g:A\rightarrow B$ãŒã‚ã£ã¦ï¼Œã™ã¹ã¦ã® points $a:1\rightarrow A$ã«ã¤ã„ã¦$f\circ a = g\circ a$ãŒæˆã‚ŠãŸã¦ã°ï¼Œ$f$ã¨$g$ã¯ç­‰ã—ã„å°„ï¼

â˜† ã“ã‚Œã¯ PureScript ã®åœ(Haskell ã®å ´åˆ$Hask$ãªã®ã§$Pure$ï¼Ÿ)ã§ã‚‚æˆã‚Šç«‹ã¤ã®ã§ã¯ï¼Ÿ

ãã®å‰ã«$Pure$ã®æ§‹æˆã‚’ã°

- å¯¾è±¡: kind`Type`ã‚’æŒã¤å‹
- å°„: é–¢æ•°

ã§è‰¯ã„ã¨æ€ã†ãŒâ€¦â€¦

> https://myuon.github.io/posts/versus-hask-category/

$Hask$åœã¯åœã«ãªã‚‰ãªã„ã‚‰ã—ã„ã§ã™ï¼ãªã‚“ã¦ã“ã£ãŸ
PureScript ã¯æ­£æ ¼è©•ä¾¡ãªã®ã§`call-by-need`ã®å•é¡Œã¯ãªã„ã§ã—ã‚‡ã†ãŒï¼Œ`undefined`ã«ã¤ã„ã¦ã¯ã‚ã‹ã‚‰ãªã„ã§ã™ï¼
ã§ã‚‚`FFI`ã‚’æ’é™¤ã—ãŸ PureScript ã«ã¯`undefined`ã¯ç„¡ã„ã‹ã‚‚ã—ã‚Œãªã„ï¼ã“ã“ã‚‰è¾ºã¯ã‚ã¨ã§è€ƒãˆãŸã„ã§ã™ï¼

â˜† ã«æˆ»ã‚‹ï¼$Pure$ã§è¨€ã„æ›ãˆã‚‹ã¨ï¼Œ
`f :: A -> B`ã¨ï¼Œ`g :: A -> B` ãŒã‚ã£ã¦ï¼Œä»»æ„ã®`a :: Unit -> A`ã«ã¤ã„ã¦`(f <<< a) unit == (g <<< a) unit`ã§ã‚ã‚‹ã¨ãï¼Œä»»æ„ã®`e :: A`ã«ã¤ã„ã¦ï¼Œ`f e == g e`ï¼
ã¨ãªã‚‹
(é–¢æ•°`f`ã¨`g`ã®åŒå€¤ã‚’ã™ã¹ã¦ã®`e`ã«ã¤ã„ã¦`f e == g e`ã¨å®šç¾©ã—ãŸï¼)

è¨¼æ˜)
ä»»æ„ã®`e :: A`ã«ã¤ã„ã¦ï¼Œ`a = const e`ã¨ã™ã‚Œã°ï¼Œ`f e == (f <<< a) unit == (g <<< a) unit === g e`

# 2.4

å¯¾è±¡$A$ã¨$B$ã®ç©ã¯$P$ã¨$p_1:P\rightarrow A$ $p_2:P\rightarrow A$ï¼Œã®çµ„ã§ã‚ã‚Šï¼Œä»»æ„ã®å¯¾è±¡$X$ã¨å°„$x_1:X\rightarrow A$ï¼Œ$x_2:X\rightarrow B$ã«ã¤ã„ã¦ï¼Œå”¯ä¸€ã®å°„$u:X\rightarrow P$ãŒå­˜åœ¨ã—ã¦$x_1 = p_1\circ u$ï¼Œ$x_2 = p_2\circ u$ã‚’æº€ãŸã™ã‚‚ã®

ã“ã®$u$ã‚’$\langle x_1, x_2\rangle$ã¨æ›¸ã

(è€ƒå¯Ÿ)ã“ã‚Œã¯"ä¸€èˆ¬åŒ–ã•ã‚ŒãŸè¦ç´ "ã®è€ƒãˆæ–¹ã‚’ä½¿ãˆã°ï¼Œ$x_1$ã¯$A$ã®è¦ç´ ï¼Œ$x_2$ã¯$B$ã®è¦ç´ ï¼Œ$u$ã¯$P$ã®è¦ç´ ã¨ãªã‚‹ã®ã§ï¼Œè¨€ã„æ›ãˆã‚Œã°
ã€Œ$A$ã¨$B$ã®ç›´ç©$P$ã¯$A$ã®è¦ç´ $a$ã¨$B$ã®è¦ç´ $b$ã«ã¤ã„ã¦ï¼Œå”¯ä¸€ã®$P$ã®è¦ç´ $p$ãŒã‚ã£ã¦$a=p_1(p)$,$b=p_2(p)$ã¨ãªã‚‹ã‚ˆã†ãª$P$ã€ã¨é›†åˆã®ç›´ç©ã¿ãŸã„ãªæ›¸ãæ–¹ã«ãªã‚‹ã®ã§ï¼ŒãŠæ°—æŒã¡ãŒã‚ã‹ã‚Šã‚„ã™ã„(å…¨ç„¶çš„å¤–ã‚Œã‹ã‚‚ã—ã‚Œãªã„)

ã“ã‚Œã¯ç›´ç©å‹ã¨å·¦å³ãã‚Œãã‚Œã®å€¤ã‚’å–ã‚Šå‡ºã™é–¢æ•°ã«å¯¾å¿œã—ã¦ã„ã‚‹ï¼

```purescript
data ProductT a b = Cons a b

p1 :: forall a b. ProductT a b -> a
p1 (Cons a _) = a

p2 :: forall a b. ProductT a b -> b
p2 (Cons _ b) = b
```

ã“ã‚ŒãŒä¸Šã®å®šç¾©ã‚’æº€ãŸã™ã“ã¨ã¯æ¬¡ã®ã‚ˆã†ãªæ„Ÿã˜ã§$u$ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ãŒå®šç¾©ã§ãã¦

```purescript
genU :: forall x a b. (x -> a) -> (x -> b) -> x -> ProductT a b
genU x1 x2 x = Cons (x1 x) (x2 x)
```

ã“ã‚ŒãŒå®¹æ˜“ã«ç¢ºã‹ã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ä»»æ„ã®`x :: X`ã«ã¤ã„ã¦
`x1 x == (p1 <<< genU x1 x2) x`ã‹ã¤`x2 x == (p2 <<< genU x1 x2) x`
ã§ã‚ã‚‹ã“ã¨ã‹ã‚‰è¨€ãˆã‚‹ãŒï¼Œãã®å‰ã«ã“ã®ã‚ˆã†ãªé–¢æ•°`genU`ãŒä¸€æ„ã§ã‚ã‚‹ã“ã¨ã‚’è¨€ã‚ãªãã¦ã¯ã„ã‘ãªã„ï¼

ã“ã“ã§ã‚ã‚‹é–¢æ•°`genU' :: forall x a b. (x -> a) -> (x -> b) -> x -> ProductT a b`ã«ã¤ã„ã¦ï¼Œ
`x1 x == (p1 <<< genU' x1 x2) x`ã‹ã¤`x2 x == (p2 <<< genU' x1 x2) x`
ãŒæˆã‚Šç«‹ã¤ã¨ï¼Œã™ãªã‚ã¡
`x1 x == p1 (genU' x1 x2 x)`ã‹ã¤`x2 x == p2 (genU' x1 x2 x)`
ã ãŒï¼Œp1 ã¨ p2 ã®å®šç¾©ã‹ã‚‰
`genU' x1 x2 x = Cons (x1 x) (x2 x)`
ã¨ãªã‚Šï¼Œã“ã‚Œã¯`genU`ã¨ç­‰ã—ã„ã®ã§ï¼Œä¸€æ„ï¼

ã‚ã¨ï¼Œã‚¯ãƒ©ã‚¹åŒ–ã—ã¦ã¿ã‚‹ï¼$a$ã¨$b$ã®ä»»æ„ã®ç›´ç©ã®é–“ã«ã¯åŒå‹å°„ãŒå­˜åœ¨ã™ã‚‹ãŸã‚ï¼Œæ¬¡ã®ã‚ˆã†ãªã‚¯ãƒ©ã‚¹ã‚’ç”¨æ„ã—ã¦ãŠã‘ã°ã‚ˆã„ï¼

```purescript
class ProductC product a b | product -> a b where
  toProductT :: product -> ProductT a b
  fromProductT :: ProductT a b -> product
```

# 2.6

åœ$C$ã«ãŠã„ã¦ä»»æ„ã®å¯¾è±¡ $A$ , $A'$ ã«ã¤ã„ã¦å¯¾è±¡ $A\times A'$ ãŒå­˜åœ¨ã™ã‚‹ã¨ãï¼Œ
$f:A\rightarrow B$ã¨$f':A'\rightarrow B'$ï¼Œ$A$ã¨$A'$ã®ç›´ç©$A\times A', p_1:AÃ—A'\rightarrow A, p_2:AÃ—A'\rightarrow A'$ã«ã¤ã„ã¦ï¼Œ$f\times f'=\langle f\circ p_1, f'\circ p_2\rangle:A\times A'\rightarrow B\times B'$
ã¨ã™ã‚‹ã¨
$\times :C\times C\rightarrow C$
ã¨ã„ã†é–¢æ‰‹ãŒã§ãã‚‹ï¼(ç–‘å•ç‚¹: äºŒå€¤ã®é–¢æ‰‹(ï¼Ÿ)ã£ã¦ã“ã®æœ¬ã§å®šç¾©ã•ã‚Œã¦ãŸï¼Ÿ)

- è¨¼æ˜(é–¢æ‰‹å‰‡ã‚’æº€ãŸã™)
  - $1_A\times 1_B=1_{A\times B}$
    $A$ã¨$B$ã®ç›´ç©ã‚’$A\times B$ï¼Œ$p_1:A\times B\rightarrow A$ï¼Œ$p_2:A\times B\rightarrow B$ã¨ã™ã‚‹ï¼
    $1_A\times 1_B=\langle 1_A\circ p_1, 1_A\circ p_2\rangle=\langle p_1, p_2\rangle$
    ã“ã“ã§ï¼Œ$\langle p_1, p_2\rangle$ã¯ï¼Œã‚ã‚‹å°„$u$ã§ã‚ã£ã¦$p_1=p_1\circ u$ï¼Œ$p_2=p_2\circ u$ã‚’æº€ãŸã™ã‚‚ã®ã§ã‚ã‚Šï¼Œ$u$ã®ä¸€æ„æ€§ã‹ã‚‰$u=1_{A\times B}$
  - $f_1:A\rightarrow B$ï¼Œ$f_2:B\rightarrow C$ï¼Œ$g_1:P\rightarrow Q$ï¼Œ$g_2:Q\rightarrow R$ã«ã¤ã„ã¦$(f_2\times g_2)\circ (f_1\times  g_1)=(f_2\circ f_1)\times (g_2\circ g_1)$
    $A$ã¨$P$ã®ç›´ç©ã‚’$A\times P$ï¼Œ$p_A:A\times P\rightarrow A$ï¼Œ$p_P:A\times P\rightarrow P$ã¨ã™ã‚‹ï¼
    $B$ã¨$Q$ã®ç›´ç©ã‚’$B\times Q$ï¼Œ$p_B:B\times Q\rightarrow B$ï¼Œ$p_Q:B\times Q\rightarrow Q$ã¨ã™ã‚‹ï¼
    $(f_2\times g_2)\circ (f_1\times  g_1)=\langle f_2\circ p_B, g_2\circ p_Q\rangle\circ\langle f_1\circ p_A, g_1\circ p_P\rangle =\langle f_2\circ f_1\circ p_A, g_2\circ g_1\circ p_P\rangle = f_2\circ f_1\times g_2\circ g_1$(ä¸€æ„æ€§ã‹ã‚‰)

å¾Œè€…ã¯ã‹ãªã‚Šç«¯æŠ˜ã£ã¦ã—ã¾ã£ãŸï¼å›³å¼ã‚’æ›¸ã‘ã°ã‚ã‹ã‚Šã‚„ã™ã„ã‚“ã§ã™ãŒï¼Œæ›¸ã„ã¦åŸ‹ã‚è¾¼ã‚€ãŸã‚ã®å®‰å®šã—ãŸæ‰‹æ³•ãŒã„ã¾ã„ã¡ã‚ã‹ã‚‰ãªã„ã®ã§â€¦â€¦

PureScript ãªã‚‰ï¼Œ`ProductT`ãŒ`Bifunctor`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚‹ã“ã¨ã«å¯¾å¿œã—ã¦ã„ã‚‹ï¼

```purescript
class Bifunctor f where
  bimap :: forall a b c d. (a -> b) -> (c -> d) -> f a c -> f b d

instance Bifunctor ProductT where
  bimap f g (Cons a b) = Cons (f a) (g b)
```

ã‚‚ã¡ã‚ã‚“é–¢æ‰‹å‰‡ã‚’æº€ãŸã™ãŒï¼Œä¸€å¿œç¢ºã‹ã‚ã‚‹

```purescript
bimap identity identity
  == \(Cons a b) -> Cons a b
  == identity
bimap f1 g1 <<< bimap f2 g2
  == (\(Cons a b) -> Cons (f1 a) (g1 b)) <<< (\(Cons a b) -> Cons (f2 a) (g2 b))
  == \(Cons a b) -> Cons (f1 <<< f2 $ a) (g1 <<< g2 $ b)
  == bimap (f1 <<< f2) (g1 <<< g2)
```

# 2.7

- å®šç†
  å¯¾è±¡$A$ï¼Œ$B$ï¼ŒãŠã‚ˆã³$P$ï¼Œå°„$p_1:P\rightarrow A$ï¼Œ$p_2:P\rightarrow B$ã‚’ä¸ãˆï¼Œä»»æ„ã®$X$ã«å¯¾ã—
  $\vartheta _X:\rm{Hom}(X,P)\rightarrow \rm{Hom}(X,A)\times\rm{Hom}(X,B)$
  ã‚’æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹
  $\vartheta _X(x)=(p_1\circ x, p_2\circ x)$
  ã“ã®æ™‚ï¼Œã€Œ$P$ãŒ$A$ã¨$B$ã®ç›´ç©ã§ã‚ã‚‹ã“ã¨ã€ã¯ï¼Œã€Œä»»æ„ã®$X$ã«å¯¾ã—$\vartheta \_X$ãŒ(é›†åˆé–“ã®å†™åƒã¨ã—ã¦)åŒå‹å†™åƒã§ã‚ã‚‹ã“ã¨ã€ã¨åŒå€¤ã§ã‚ã‚‹

$Pure$ã§ã¯$\rm{Hom}(X,P)$ã¯`X -> P`ã§ã‚ã‚Šï¼Œ$Pure$ã®å¯¾è±¡(ã“ã‚Œã¯$CCC$ã®æ€§è³ªã®ä¸€éƒ¨ã‚‰ã—ã„ https://scrapbox.io/mrsekut-p/CCC)
(ã¨æ€ã£ãŸãŒï¼Œå‹ã¨é›†åˆã¯ä¼¼ã¦éãªã‚‹ã‚‚ã®ã ã¨æ€ã£ã¦ã„ã‚‹ã®ã§ï¼Œãã†è€ƒãˆã‚‹ã¨$\rm{Hom}(X,P)$ã£ã¦ãƒ›ãƒ³ãƒã«`X -> P`ã‹ï¼Ÿã¨ã„ã†æ°—æŒã¡ã«ãªã£ã¦ã„ã‚‹)

PureScript ã§è¨€ã„æ›ãˆã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚‹(ï¼Ÿ)

---

ã¾ãš Vartheta($\vartheta$)ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã™ã‚‹

```purescript
class Vartheta product a b | product -> a b where
  vartheta
    :: forall x
     . (x -> product)
    -> ProductT (x -> a) (x -> b) --Productã¯é›†åˆã®æ„å‘³ã§ã®ç›´ç©ã¨ã—ã¦ä½¿ã£ã¦ã„ã‚‹
  varthetaInv
    :: forall x
     . ProductT (x -> a) (x -> b)
    -> (x -> product)

-- æ¡ä»¶: å‹xãŒåŒã˜ãªã‚‰ï¼Œvartheta <<< varthetaInv == identityã‹ã¤varthetaInv <<< vartheta == identity
```

ä»»æ„ã®å‹$x$ã«å¯¾ã—ã¦$\vartheta _x$, ãŠã‚ˆã³$\vartheta _x^{-1}$ã‚’ãŒã‚ã‚‹ã“ã¨ã‚’è¡¨ã—ã¦ã„ã‚‹($\vartheta _x$ãŒåŒå‹å†™åƒã§ã‚ã‚‹ã“ã¨ã¨ï¼Œé€†å†™åƒãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã¯åŒå€¤)

ã¾ãŸã“ã“ã§ã®`product`å‹å¤‰æ•°ã¯`a`ã¨`b`ã®ç›´ç©ã§ã‚ã‚‹å¿…è¦ã¯ãªã„ï¼

ã“ã®ä¸Šã§ï¼Œã‚ã‚‹å‹`product`ãŒï¼Œä»»æ„ã®å‹`x`ã«å¯¾ã—ã¦ï¼Œ`Vartheta product a b`ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹ã¨ã`ProductC product a b`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå­˜åœ¨ã™ã‚‹ï¼ã•ã‚‰ã«ï¼Œãã®é€†ã‚‚æˆã‚Šç«‹ã¤ï¼

---

å…·ä½“çš„ãªæ§‹æˆã‚’ã™ã‚‹ï¼

```purescript
instance Vartheta product a b => ProductC product a b where
  toProductT p = Cons (a unit) (b unit)
    where
    Cons a b = vartheta (const p)
  fromProductT (Cons a b) = varthetaInv (Cons (const a) (const b)) unit

instance ProductC product a b => Vartheta product a b where
  vartheta = f
    where
    f p = Cons a b
      where
      a x = p1 $ toProductT (p x)
      b x = p2 $ toProductT (p x)
  varthetaInv = fInv
    where
    fInv (Cons a b) x = fromProductT $ Cons (a x) (b x)
```

- å®šç†
  é–¢æ‰‹$\rm{Hom}(X,-)$ã¯ç›´ç©ã‚’ä¿å­˜ã™ã‚‹ï¼

PureScript ã§è¨€ã„æ›ãˆã‚‹ã¨
å‹`a`ï¼Œ`b`ï¼Œ`product`ã«å¯¾ã—ã¦ï¼Œ`ProductC product a b`ã§ã‚ã‚‹ã¨ãï¼Œä»»æ„ã®å‹`x`ã«å¯¾ã—ã¦`x -> product`ã¨`ProductC product2 (x -> a) (x -> b)`ãªã‚‹å‹`product2`ã®é–“ã«åŒå‹å°„ãŒã‚ã‚‹ï¼

ã“ã“ã§`ProductC product a b`ãªã‚‹ä»»æ„ã®`product`ã¯`ProductT a b`ã®é–“ã«ã¯åŒå‹å°„ãŒå­˜åœ¨ã™ã‚‹ã®ã§ï¼Œä»»æ„ã®å‹`a, b`ã¨`x`ã«å¯¾ã—ã¦`x -> ProductT a b`ã¨`ProductT (x -> a) (x -> b)`ã®é–“ã«åŒå‹å°„ãŒã‚ã‚‹ï¼Œã¨è¨€ã„æ›ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ï¼

å…·ä½“çš„ãªæ§‹æˆã‚’ã™ã‚‹ï¼

```purescript
testHomFunctor
  :: forall a b x
   . (x -> ProductT a b)
  -> ProductT (x -> a) (x -> b)
testHomFunctor p = Cons a b
  where
  a x = p1 $ p x
  b x = p2 $ p x

testHomFunctorInv
  :: forall a b x
   . ProductT (x -> a) (x -> b) -> (x -> ProductT a b)
testHomFunctorInv (Cons a b) x = Cons (a x) (b x)
```

`testHomFunctor <<< testHomFunctorInv == identity`ã¨ãªã‚‹ï¼

# æ„Ÿæƒ³

æ„å¤–ã¨æ™‚é–“ãŒã‹ã‹ã£ã¦ã—ã¾ã„ã¾ã—ãŸï¼ã‚³ãƒ³ã‚¹ã‚¿ãƒ³ãƒˆã«æ›¸ãç¶šã‘ã‚‰ã‚Œã‚‹ã‹ä¸å®‰ã§ã™ï¼ã‚ã¨ï¼Œè‰²ã€…ãªå…·ä½“ä¾‹ãŒè¼‰ã£ã¦ã„ãŸ 2.5 ç« ã¨ç·´ç¿’å•é¡Œã¯é£›ã°ã—ã¦ã„ã¾ã™ï¼PureScript ã§å®Ÿè£…ã—ãŸã„å†…å®¹ãŒã‚ã£ãŸã‚‰åˆ¥è¨˜äº‹ã«æ›¸ããŸã„ã¨æ€ã„ã¾ã™ï¼
